Detailed Use of useEffect in React:

1. Purpose:
   - useEffect is used to perform side effects in functional components.
   - Side effects include data fetching, subscriptions, timers, DOM manipulation, and logging.

2. Syntax:
   useEffect(() => {
     // effect logic
     return () => {
       // optional cleanup
     };
   }, [dependencies]);

3. Execution Behavior:
   - Runs after every render by default.
   - If a dependency array is provided:
     - [] â†’ runs only once (on mount).
     - [dep] â†’ runs on mount + whenever dep changes.
   - The cleanup function runs before the next effect or on unmount.

4. Common Use Cases:
   a. Fetch data on component mount.
   b. Add event listeners (e.g., scroll, resize).
   c. Start/clear timers (e.g., setInterval).
   d. Update document title or manipulate DOM.
   e. Subscribe/unsubscribe from services (e.g., WebSocket, Firebase).

5. Cleanup Function:
   - Prevents memory leaks by removing listeners, clearing timers, etc.
   - Runs before re-running the effect or when component unmounts.

6. Best Practices:
   - Always specify dependencies correctly to avoid unnecessary re-renders or missing updates.
   - Always clean up side effects to avoid performance issues.
   - For async operations, handle cancellation or use AbortController.

Conclusion:
useEffect connects your component with the outside world by allowing side-effect logic. It ensures proper setup and teardown of effects during the component's lifecycle.



React Component Lifecycle in Class vs useEffect (Functional Components)

1. Class Component Lifecycle Methods:
   a. constructor()              â†’ Initialization
   b. componentDidMount()        â†’ Runs once after first render (setup, API calls)
   c. componentDidUpdate()       â†’ Runs after state/props update
   d. componentWillUnmount()     â†’ Runs before component is removed (cleanup)

2. Equivalent using useEffect in Functional Components:

a. componentDidMount
   useEffect(() => {
     // logic runs once after initial render
   }, []);

b. componentDidUpdate
   useEffect(() => {
     // logic runs on every dependency update
   }, [dependency]);

c. componentWillUnmount
   useEffect(() => {
     // setup code

     return () => {
       // cleanup logic before unmount
     };
   }, []);

3. Combined Example:
   useEffect(() => {
     // acts like componentDidMount & componentDidUpdate

     return () => {
       // acts like componentWillUnmount
     };
   }, [dependency]);

4. Summary:
   - Class components have distinct lifecycle methods.
   - useEffect merges all lifecycle behaviors into a single API using the dependency array and cleanup return.
   - Functional components with useEffect are now the standard approach in modern React.


useEffect Execution Flow:

1. Initial Render:
   - Runs effect logic.
   - Logs:
     - "inside useeffect"
     - "name has changed"

2. On every 'name' update:
   - First runs the cleanup from previous effect.
     - Logs: "return function in useEffect"
   - Then runs the new effect.
     - Logs:
       - "inside useeffect"
       - "name has changed"

3. On component unmount:
   - Only cleanup runs.
     - Logs: "return function in useEffect"

Reason:
React cleans up previous effects before re-running to prevent memory leaks and ensure correct behavior.

No, useState does NOT persist data after refresh.

Explanation:
- useState stores data only in memory during the component's lifecycle.
- On browser refresh, the entire React app reloads, resetting all state to initial values.
- State is not saved to disk or storage by default.

To persist data across refreshes, use:
1. localStorage or sessionStorage
2. IndexedDB
3. Backend/database with API call

No, the return function in useEffect does NOT clear useState.

Explanation:
- The return function only cleans up side effects (like intervals, event listeners, subscriptions).
- It does NOT reset or clear state set by useState.
- useState retains its value unless you explicitly change it using setState.

Example:
- Even after cleanup runs, the state value remains unchanged unless setName("") or similar is called manually.



```txt
ðŸŸ¢ Easy Level:
1. Log a message every time a specific state variable changes.
2. Update the document title to show the number of button clicks.
3. Create a live character count for an input field using useEffect.
4. Track and display the current window width (resize listener).
5. Detect mouse position and display it using useEffect and useState.

ðŸŸ¡ Medium Level:
6. Create a counter that increases every second using setInterval with useEffect.
7. Fetch user data from an API when the component mounts.
8. Add and clean up a scroll event listener that logs the scroll position.
9. Save form data to localStorage whenever input changes.
10. Display online/offline network status using the 'online' and 'offline' window events.
11. Implement a countdown timer that clears itself when it reaches zero.

ðŸ”´ Hard Level:
12. Create a tab system that fetches data when each tab is activated.
13. Simulate a component that subscribes to a data stream and unsubscribes on unmount.
14. Build a component that warns the user before leaving the page (use beforeunload).
15. Display a modal after 5 seconds using a timeout inside useEffect.
```
Display "Enable FullScreen" message in an exam app when the user exits fullscreen or resizes (tries to shorten browser).
